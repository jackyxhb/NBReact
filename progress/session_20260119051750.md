## Q1: useCounter Custom Hook

### Problem Statement

Create a custom React hook called `useCounter` that manages a counter state with the following functionality:

1. **Initial value:** Accept an optional `initialValue` parameter (defaults to 0)
2. **Increment:** A function to increase the counter by 1 (or by a custom step value)
3. **Decrement:** A function to decrease the counter by 1 (or by a custom step value)
4. **Reset:** A function to reset the counter to the initial value
5. **Set:** A function to set the counter to a specific value

### Requirements

- The hook must use `useState` internally
- All functions should be memoized using `useCallback`
- `increment` and `decrement` accept optional step parameter
- Return an object with `count` and all control functions

### Sample Usage

```javascript
function CounterComponent() {
  const { count, increment, decrement, reset, set } = useCounter(10);
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => increment()}>+1</button>
      <button onClick={() => increment(5)}>+5</button>
      <button onClick={() => decrement()}>-1</button>
      <button onClick={reset}>Reset</button>
      <button onClick={() => set(100)}>Set to 100</button>
    </div>
  );
}
```

### Solution

```javascript
import { useState, useCallback } from 'react';

function useCounter(initialValue = 0) {
  const [count, setCount] = useState(initialValue);

  const increment = useCallback((step = 1) => {
    setCount(prev => prev + step);
  }, []);

  const decrement = useCallback((step = 1) => {
    setCount(prev => prev - step);
  }, []);

  const reset = useCallback(() => {
    setCount(initialValue);
  }, [initialValue]);

  const set = useCallback((value) => {
    setCount(value);
  }, []);

  return { count, increment, decrement, reset, set };
}

export default useCounter;
```

---

## Q2: useFetch Custom Hook

### Problem Statement

Create a custom React hook called `useFetch` that handles data fetching with loading and error states. The hook should:

1. **Accept a URL** as a parameter
2. **Return an object** with `data`, `loading`, `error`, and `refetch` properties
3. **Fetch data** when the component mounts or when the URL changes
4. **Handle loading state** while the request is in progress
5. **Handle errors** gracefully
6. **Provide a refetch function** to manually trigger a new request

### Requirements

- Use `useState` for `data`, `loading`, and `error` states
- Use `useEffect` to trigger the fetch
- Use `useCallback` for the `refetch` function
- Handle cleanup when component unmounts (AbortController)
- The `loading` state should be `true` initially and while fetching
- Set `data` to `null` initially and on error

### Sample Usage

```javascript
function UserProfile({ userId }) {
  const { data, loading, error, refetch } = useFetch(
    `https://api.example.com/users/${userId}`
  );

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;

  return (
    <div>
      <h1>{data.name}</h1>
      <p>{data.email}</p>
      <button onClick={refetch}>Refresh</button>
    </div>
  );
}
```

### Solution

```javascript
import { useState, useEffect, useCallback } from 'react';

function useFetch(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  const fetchData = useCallback(async () => {
    const controller = new AbortController();
    
    try {
      setLoading(true);
      setError(null);
      
      const response = await fetch(url, { signal: controller.signal });
      
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      
      const json = await response.json();
      setData(json);
    } catch (err) {
      if (err.name !== 'AbortError') {
        setError(err);
        setData(null);
      }
    } finally {
      setLoading(false);
    }
    
    return controller;
  }, [url]);

  useEffect(() => {
    const controller = fetchData();
    return () => {
      controller.then(c => c?.abort());
    };
  }, [fetchData]);

  return { data, loading, error, refetch: fetchData };
}

export default useFetch;
```

---

## Q3: useDebounce Custom Hook

### Problem Statement

Create a custom React hook called `useDebounce` that delays updating a value until after a specified delay has passed since the last change. This is commonly used for:

1. Search input fields (wait for user to stop typing)
2. Window resize handlers
3. API call throttling

### Requirements

- Accept `value` and `delay` (ms) as parameters
- Return the debounced value
- Use `useState` to store the debounced value
- Use `useEffect` with `setTimeout`
- Clear the timeout on cleanup to prevent memory leaks
- Clear the timeout when value changes before delay completes

### Sample Usage

```javascript
function SearchComponent() {
  const [searchTerm, setSearchTerm] = useState('');
  const debouncedSearch = useDebounce(searchTerm, 500);

  useEffect(() => {
    if (debouncedSearch) {
      // API call only fires 500ms after user stops typing
      fetchSearchResults(debouncedSearch);
    }
  }, [debouncedSearch]);

  return (
    <input
      value={searchTerm}
      onChange={(e) => setSearchTerm(e.target.value)}
      placeholder="Search..."
    />
  );
}
```

### Solution

```javascript
import { useState, useEffect } from 'react';

function useDebounce(value, delay) {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    const timeoutId = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => clearTimeout(timeoutId);
  }, [value, delay]);

  return debouncedValue;
}

export default useDebounce;
```

---

## Q4: useLocalStorage Custom Hook

### Problem Statement

Create a custom React hook called `useLocalStorage` that syncs state with localStorage, allowing data to persist across page refreshes.

1. Accept a `key` (string) and `initialValue`
2. Return `[storedValue, setValue]` like useState
3. Read from localStorage on mount
4. Write to localStorage when value changes
5. Handle JSON serialization/deserialization

### Requirements

- Use `useState` with lazy initialization
- Handle cases where localStorage is empty (use initialValue)
- Serialize values with `JSON.stringify`
- Deserialize with `JSON.parse`
- Handle errors gracefully (invalid JSON, storage full)
- The setter should work like useState's setter

### Sample Usage

```javascript
function ThemeToggle() {
  const [theme, setTheme] = useLocalStorage('theme', 'light');

  return (
    <button onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')}>
      Current: {theme}
    </button>
  );
}

// After page refresh, theme persists!
```

### Solution

```javascript
import { useState } from 'react';

function useLocalStorage(key, initialValue) {
  const [storedValue, setStoredValue] = useState(() => {
    try {
      const item = localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error('Error reading localStorage:', error);
      return initialValue;
    }
  });

  const setValue = (value) => {
    try {
      const valueToStore = value instanceof Function ? value(storedValue) : value;
      setStoredValue(valueToStore);
      localStorage.setItem(key, JSON.stringify(valueToStore));
    } catch (error) {
      console.error('Error writing localStorage:', error);
    }
  };

  return [storedValue, setValue];
}

export default useLocalStorage;
```

---

## Q5: useToggle Custom Hook

### Problem Statement

Create a simple but flexible `useToggle` hook that manages boolean state with multiple control methods:

1. **Toggle:** Flip the current value
2. **Set On:** Force to `true`
3. **Set Off:** Force to `false`
4. **Set Value:** Set to specific boolean

### Requirements

- Accept optional `initialValue` (defaults to `false`)
- Return `[value, { toggle, setOn, setOff, setValue }]`
- All control functions should be memoized with `useCallback`
- Functions should have stable references (empty dependency arrays)
- Use functional updates to avoid stale closures

### Sample Usage

```jsx
function Modal() {
  const [isOpen, { toggle, setOn, setOff }] = useToggle(false);

  return (
    <div>
      <button onClick={setOn}>Open Modal</button>
      
      {isOpen && (
        <div className="modal">
          <h2>Modal Content</h2>
          <button onClick={setOff}>Close</button>
        </div>
      )}
      
      <button onClick={toggle}>Toggle Modal</button>
    </div>
  );
}
```

### Solution

```javascript
import { useState, useCallback } from 'react';

function useToggle(initialValue = false) {
  const [value, setValue] = useState(initialValue);

  const toggle = useCallback(() => {
    setValue(prev => !prev);
  }, []);

  const setOn = useCallback(() => setValue(true), []);
  const setOff = useCallback(() => setValue(false), []);
  const set = useCallback((v) => setValue(v), []);

  return [value, { toggle, setOn, setOff, setValue: set }];
}

export default useToggle;
```

---
